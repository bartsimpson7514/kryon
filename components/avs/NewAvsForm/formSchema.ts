import { z } from "zod"

const SquaringProblem =
  'type Task struct {\n	NumberToBeSquared         *big.Int\n	TaskCreatedBlock          uint32\n	QuorumNumbers             []byte\n	QuorumThresholdPercentage uint32\n}\n\ntype TaskResponse struct {\n	ReferenceTaskIndex uint32\n	NumberSquared      *big.Int\n}\n\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *kryonTaskmanager.ContractKryonAvsTaskManagerNewTaskCreated) *kryonTaskmanager.IKryonAvsTaskManagerTaskResponse {\n	o.logger.Debug("Received new task", "task", newTaskCreatedLog)\n	o.logger.Info("Received new task",\n		"numberToBeSquared", newTaskCreatedLog.Task.NumberToBeSquared,\n		"taskIndex", newTaskCreatedLog.TaskIndex,\n		"taskCreatedBlock", newTaskCreatedLog.Task.TaskCreatedBlock,\n		"quorumNumbers", newTaskCreatedLog.Task.QuorumNumbers,\n		"QuorumThresholdPercentage", newTaskCreatedLog.Task.QuorumThresholdPercentage,\n	)\n	numberSquared := big.NewInt(0).Exp(newTaskCreatedLog.Task.NumberToBeSquared, big.NewInt(2), nil)\n	taskResponse := &kryonTaskmanager.IKryonAvsTaskManagerTaskResponse{\n		ReferenceTaskIndex: newTaskCreatedLog.TaskIndex,\n		NumberSquared:      numberSquared,\n	}\n	return taskResponse\n}\n\n\nfunc (c *Challenger) ValidateTaskResponse(taskIndex uint32) error {\n	numberToBeSquared := c.tasks[taskIndex].NumberToBeSquared\n	answerInResponse := c.taskResponses[taskIndex].TaskResponse.NumberSquared\n	trueAnswer := numberToBeSquared.Exp(numberToBeSquared, big.NewInt(2), nil)\n\n	// checking if the answer in the response submitted by aggregator is correct\n	if trueAnswer.Cmp(answerInResponse) != 0 {\n		c.logger.Infof("The number squared is not correct")\n\n		// raise challenge\n		c.raiseChallenge(taskIndex)\n\n		return nil\n	}\n	return types.NoErrorInTaskResponse\n}\n'
const Python =
  "from decimal import Decimal\nimport logging\n\n# Assuming a mapping of your Go structs to Python classes or dictionaries\nclass Task:\n    def __init__(self, number_to_be_squared, task_created_block, quorum_numbers, quorum_threshold_percentage):\n        self.number_to_be_squared = Decimal(number_to_be_squared)\n        self.task_created_block = task_created_block\n        self.quorum_numbers = quorum_numbers  # List of bytes\n        self.quorum_threshold_percentage = quorum_threshold_percentage\n\nclass TaskResponse:\n    def __init__(self, reference_task_index, number_squared):\n        self.reference_task_index = reference_task_index\n        self.number_squared = Decimal(number_squared)\n\n# Logger setup\nlogger = logging.getLogger('Operator')\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Operator:\n    def process_new_task_created_log(self, new_task_created_log):\n        logger.debug(\"Received new task\", extra={\"task\": new_task_created_log})\n        logger.info(\"Received new task\", extra={\n            \"number_to_be_squared\": new_task_created_log['task']['number_to_be_squared'],\n            \"task_index\": new_task_created_log['task_index'],\n            \"task_created_block\": new_task_created_log['task']['task_created_block'],\n            \"quorum_numbers\": new_task_created_log['task']['quorum_numbers'],\n            \"quorum_threshold_percentage\": new_task_created_log['task']['quorum_threshold_percentage'],\n        })\n        number_squared = new_task_created_log['task']['number_to_be_squared'] ** 2\n        task_response = {\n            'reference_task_index': new_task_created_log['task_index'],\n            'number_squared': number_squared\n        }\n        return task_response\n\nclass Challenger:\n    def __init__(self):\n        self.tasks = {}\n        self.task_responses = {}\n        self.logger = logging.getLogger('Challenger')\n\n    def validate_task_response(self, task_index):\n        number_to_be_squared = self.tasks[task_index]['number_to_be_squared']\n        answer_in_response = self.task_responses[task_index]['number_squared']\n        true_answer = number_to_be_squared ** 2\n\n        # checking if the answer in the response submitted by aggregator is correct\n        if true_answer != answer_in_response:\n            self.logger.info(\"The number squared is not correct\")\n\n            # raise challenge\n            self.raise_challenge(task_index)\n            return None\n        return 'NoErrorInTaskResponse'\n\n    def raise_challenge(self, task_index):\n        self.logger.debug(f'Raising challenge for task index: {task_index}')"
const Javascript =
  'class Task {\n    constructor(numberToBeSquared, taskCreatedBlock, quorumNumbers, quorumThresholdPercentage) {\n        this.numberToBeSquared = BigInt(numberToBeSquared);\n        this.taskCreatedBlock = taskCreatedBlock;\n        this.quorumNumbers = quorumNumbers; // Uint8Array or ArrayBuffer\n        this.quorumThresholdPercentage = quorumThresholdPercentage;\n    }\n}\n\nclass TaskResponse {\n    constructor(referenceTaskIndex, numberSquared) {\n        this.referenceTaskIndex = referenceTaskIndex;\n        this.numberSquared = BigInt(numberSquared);\n    }\n}\n\nclass Operator {\n    constructor(logger) {\n        this.logger = logger;\n    }\n\n    processNewTaskCreatedLog(newTaskCreatedLog) {\n        this.logger.debug("Received new task", { task: newTaskCreatedLog });\n        this.logger.info("Received new task", {\n            numberToBeSquared: newTaskCreatedLog.task.numberToBeSquared,\n            taskIndex: newTaskCreatedLog.taskIndex,\n            taskCreatedBlock: newTaskCreatedLog.task.taskCreatedBlock,\n            quorumNumbers: newTaskCreatedLog.task.quorumNumbers,\n            quorumThresholdPercentage: newTaskCreatedLog.task.quorumThresholdPercentage,\n        });\n        let numberSquared = newTaskCreatedLog.task.numberToBeSquared ** BigInt(2);\n        let taskResponse = {\n            referenceTaskIndex: newTaskCreatedLog.taskIndex,\n            numberSquared: numberSquared\n        };\n        return taskResponse;\n    }\n}\n\nclass Challenger {\n    constructor(logger) {\n        this.tasks = {};\n        this.taskResponses = {};\n        this.logger = logger;\n    }\n\n    validateTaskResponse(taskIndex) {\n        let numberToBeSquared = this.tasks[taskIndex].numberToBeSquared;\n        let answerInResponse = this.taskResponses[taskIndex].numberSquared;\n        let trueAnswer = numberToBeSquared ** BigInt(2);\n\n        // checking if the answer in the response submitted by aggregator is correct\n        if (trueAnswer !== answerInResponse) {\n            this.logger.info("The number squared is not correct");\n\n            // raise challenge\n            this.raiseChallenge(taskIndex);\n            return null;\n        }\n        return \'NoErrorInTaskResponse\';\n    }\n\n    raiseChallenge(taskIndex) {\n        this.logger.debug(`Raising challenge for task index: ${taskIndex}`);\n    }\n}\n\n// Example usage\nconst logger = {\n    debug: console.log,\n    info: console.info\n};\n\nconst operator = new Operator(logger);\nconst challenger = new Challenger(logger);'
// Template definitions
export const templates: { [key: string]: string } = {
  SquaringProblem,
  Go: SquaringProblem,
  Javascript,
  Python,
  KeeperNetwork: `type Task struct {\n\tCollateralValue           *big.Int  // Value of the collateral\n\tDebtValue                 *big.Int  // Debt value\n\tLoanToValueThreshold      *big.Int  // LTV threshold percentage\n\tTaskCreatedBlock          uint32\n\tQuorumNumbers             []byte\n\tQuorumThresholdPercentage uint32\n}\n\ntype TaskResponse struct {\n\tReferenceTaskIndex uint32\n\tLiquidationTriggered bool  // Whether liquidation was triggered\n}\n\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *kryonTaskmanager.ContractKryonAvsTaskManagerNewTaskCreated) *kryonTaskmanager.IKryonAvsTaskManagerTaskResponse {\n\t// Monitor the LTV ratio and trigger liquidation if threshold is breached\n\t// If DebtValue / CollateralValue > LoanToValueThreshold, trigger liquidation\n}\n\nfunc (c *Challenger) ValidateTaskResponse(taskIndex uint32) error {\n\t// Validate that liquidation was correctly triggered based on the LTV ratio\n}\n`,
  TrainingAIModels: `type Task struct {\n\tEpochNumber               uint32\n\tModelAccuracyThreshold    float64  // Accuracy threshold that must be met\n\tTaskCreatedBlock          uint32\n\tQuorumNumbers             []byte\n\tQuorumThresholdPercentage uint32\n}\n\ntype TaskResponse struct {\n\tReferenceTaskIndex uint32\n\tModelAccuracy       float64  // Model accuracy after training\n}\n\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *kryonTaskmanager.ContractKryonAvsTaskManagerNewTaskCreated) *kryonTaskmanager.IKryonAvsTaskManagerTaskResponse {\n\t// Perform federated learning on local data and return the model's accuracy\n}\n\nfunc (c *Challenger) ValidateTaskResponse(taskIndex uint32) error {\n\t// Validate that model accuracy has improved and reached the threshold\n}\n`,
  BlockchainDataIndexing: `type Task struct {\n\tDataToIndex               string   // Description of the blockchain data to be indexed (e.g., transaction logs)\n\tIPFSHashFormat            string   // IPFS format or schema\n\tTaskCreatedBlock          uint32\n\tQuorumNumbers             []byte\n\tQuorumThresholdPercentage uint32\n}\n\ntype TaskResponse struct {\n\tReferenceTaskIndex uint32\n\tIPFSHash           string   // IPFS hash where the indexed data is stored\n}\n\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *kryonTaskmanager.ContractKryonAvsTaskManagerNewTaskCreated) *kryonTaskmanager.IKryonAvsTaskManagerTaskResponse {\n\t// Extract blockchain data and store it in IPFS, returning the hash\n}\n\nfunc (c *Challenger) ValidateTaskResponse(taskIndex uint32) error {\n\t// Validate that the correct blockchain data was indexed and stored at the provided IPFS hash\n}\n`,
  PredictionMarkets: `type Task struct {\n\tPredictionQuery            string   // The prediction question (e.g., ETH price at X time)\n\tTaskCreatedBlock           uint32\n\tQuorumNumbers              []byte\n\tQuorumThresholdPercentage  uint32\n}\n\ntype TaskResponse struct {\n\tReferenceTaskIndex uint32\n\tPredictionOutcome   string   // Outcome of the prediction (e.g., actual price or value)\n}\n\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *kryonTaskmanager.ContractKryonAvsTaskManagerNewTaskCreated) *kryonTaskmanager.IKryonAvsTaskManagerTaskResponse {\n\t// Fetch the deterministic data (on-chain or off-chain) and match the trades\n}\n\nfunc (c *Challenger) ValidateTaskResponse(taskIndex uint32) error {\n\t// Validate that the prediction outcome was based on accurate data\n}\n`,
  IntentSolver: `type Task struct {\n\tUserIntent                string   // The user's intent (e.g., "swap 100 USDC to ETH")\n\tTaskCreatedBlock          uint32\n\tQuorumNumbers             []byte\n\tQuorumThresholdPercentage uint32\n}\n\ntype TaskResponse struct {\n\tReferenceTaskIndex uint32\n\tBestExecutionRoute string   // Best route for executing the intent (e.g., path of liquidity pools)\n}\n\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *kryonTaskmanager.ContractKryonAvsTaskManagerNewTaskCreated) *kryonTaskmanager.IKryonAvsTaskManagerTaskResponse {\n\t// Analyze various execution routes and select the optimal one based on intent\n}\n\nfunc (c *Challenger) ValidateTaskResponse(taskIndex uint32) error {\n\t// Validate that the chosen execution route is indeed optimal\n}\n`,
}

export const FormSchema = z.object({
  avsName: z.string().min(1, "AVS Name is required").trim(),
  avsFramework: z.string().min(1, "AVS Framework is required").trim(),
  supportedTokens: z
    .string()
    .min(1, "At least one supported token is required"),
  taskType: z.string().min(1, "Task Type is required").trim(),
  validationTaskLogic: z.string().min(1, "Validation Logic is required").trim(),
})
